
# python_sigrok2
Pythonic sigrok wrapper.

> The sigrok project aims at creating a portable, cross-platform, Free/Libre/Open-Source signal analysis software suite that supports various device types (e.g. logic analyzers, oscilloscopes, and many more).
> - https://sigrok.org/

## Motivation 

Python language bindings are autogenerated.

https://sigrok.org/api/libsigrok/unstable/bindings/python/index.html




```python
from __future__ import print_function
from sigrok.core.classes import *
```


```python
context = Context.create()
```


```python
for driver in context.drivers.values():
    devices = driver.scan()
    break
```

Leading to 'helpful' output like this:


```python
driver
```




    <sigrok.core.classes.Driver; proxy of <Swig Object of type 'std::shared_ptr< sigrok::Driver > *' at 0x7f133848bd50> >



, this:


```python
devices
```




    ()




```python
for device in devices:
    break
```

and this:


```python
device
```




    <sigrok.core.classes.HardwareDevice; proxy of <Swig Object of type 'std::vector< std::shared_ptr< sigrok::HardwareDevice > >::value_type *' at 0x7f133848bb10> >



With Python it's easy to wrap that in something helpful:


```python
for driver in context.drivers.values():
    devices = driver.scan()
    for device in devices:
        print(device.driver.name)
        if device.driver.name.startswith("dream"):
            device_ = device
```

    dreamsourcelab-dslogic
    demo



```python
device_
```




    <sigrok.core.classes.HardwareDevice; proxy of <Swig Object of type 'std::vector< std::shared_ptr< sigrok::HardwareDevice > >::value_type *' at 0x7f1337ba73c0> >




```python
class Device2(object):
    def __init__(self, device):
        self.device = device
        
    def __repr__(self):
        return "SigrokDevice<{}, {}, {}>".format(self.device.vendor, self.device.model, self.device.version)
        
device2 = Device2(device_)
```


```python
device2
```




    SigrokDevice<DreamSourceLab, DSLogic Basic, >



Much better.
